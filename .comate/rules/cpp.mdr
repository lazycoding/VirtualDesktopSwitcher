---
description: C++编程指南
globs: **/*.c,**/*.cpp,**/*.h,**/*.hpp,**/*.cxx,CMakeLists.txt,*.cmake,conanfile.txt,Makefile,**/*.cc
alwaysApply: false
---
# C++编程指南

## 基本原则

- 所有代码和文档使用英文
- 始终声明每个变量和函数的类型(参数和返回值)
- 创建必要的类型和类
- 使用Doxygen风格的注释来记录公共类和方法
- 函数内不要留空行
- 遵循单一定义规则(ODR)

## 命名规范

- 类和结构体使用PascalCase
- 变量、函数和方法使用camelCase
- 常量和宏使用ALL_CAPS
- 文件和目录名使用snake_case
- 环境变量使用UPPERCASE
- 避免魔法数字，定义常量
- 每个函数以动词开头
- 布尔变量使用动词。例如：isLoading, hasError, canDelete等
- 使用完整单词而非缩写，并确保拼写正确
  - 标准缩写如API、URL等除外
  - 众所周知的缩写除外：
    - 循环使用i, j, k
    - 错误使用err
    - 上下文使用ctx
    - 请求/响应参数使用req, res

## 函数

- 编写具有单一目的的短函数。少于20条指令
- 函数命名使用动词加其他内容
- 如果返回布尔值，使用isX、hasX、canX等
- 如果不返回任何内容(void)，使用executeX或saveX等
- 通过以下方式避免嵌套块：
  - 提前检查和返回
  - 提取到工具函数中
- 使用标准库算法(std::for_each, std::transform, std::find等)避免函数嵌套
- 简单操作使用lambda函数
- 非简单操作使用命名函数
- 使用默认参数值而不是检查null或nullptr
- 使用结构体或类减少函数参数
  - 使用对象传递多个参数
  - 使用对象返回多个结果
  - 为输入参数和输出声明必要的类型
- 使用单一抽象层次

## 数据

- 不要滥用基本类型，将数据封装在复合类型中
- 避免在函数中进行数据验证，使用具有内部验证的类
- 数据优先不可变性
- 不变数据使用const
- 编译时常量使用constexpr
- 可能为null的值使用std::optional

## 类

- 遵循SOLID原则
- 优先组合而非继承
- 将接口声明为抽象类或概念
- 编写具有单一目的的小类
  - 少于200条指令
  - 少于10个公共方法
  - 少于10个属性
- 资源管理使用五法则(或零法则)
- 成员变量设为私有，必要时提供getter/setter
- 成员函数使用const正确性

## 异常

- 使用异常处理意料之外的错误
- 捕获异常应该是为了：
  - 解决预期问题
  - 添加上下文
  - 否则使用全局处理器
- 预期失败使用std::optional、std::expected或错误码

## 内存管理

- 优先使用智能指针(std::unique_ptr, std::shared_ptr)而非原始指针
- 使用RAII(资源获取即初始化)原则
- 通过适当的资源管理避免内存泄漏
- 使用std::vector和其他标准容器而非C风格数组

## 测试

- 测试遵循Arrange-Act-Assert约定
- 清晰命名测试变量
- 遵循约定：inputX, mockX, actualX, expectedX等
- 为每个公共函数编写单元测试
- 使用测试替身模拟依赖
  - 执行成本不高的第三方依赖除外
- 为每个模块编写集成测试
- 遵循Given-When-Then约定

## 项目结构

- 使用模块化架构
- 代码组织到逻辑目录中：
  - include/存放头文件
  - src/存放源文件
  - test/存放测试文件
  - lib/存放库
  - doc/存放文档
- 使用CMake或类似构建系统
- 分离接口(.h)和实现(.cpp)
- 使用命名空间逻辑组织代码
- 为核心组件创建core命名空间
- 为工具函数创建utils命名空间

## 标准库

- 尽可能使用C++标准库
- 优先使用std::string而非C风格字符串
- 集合使用std::vector、std::map、std::unordered_map等
- 现代类型安全使用std::optional、std::variant、std::any
- 文件操作使用std::filesystem
- 时间相关操作使用std::chrono

## 并发

- 线程安全使用std::thread、std::mutex、std::lock_guard
- 优先基于任务的并行而非基于线程的并行
- 原子操作使用std::atomic
- 通过适当同步避免数据竞争
- 必要时使用线程安全数据结构

